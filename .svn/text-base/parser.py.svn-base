#!/usr/bin/env pythone
# -*- coding: utf-8 -*-
import traceback

from Token import *

from AST import *
from ASTAlias import *
from ASTArgItem import *
from ASTArgList import *
from ASTAttribute import *
from ASTTemplate import *
from ASTClass import *
from ASTDeclFunc import *
from ASTEmpty import *
from ASTExpr import *
from ASTExprs import *
from ASTFor import *
from ASTFuncCall import *
from ASTIf import *
from ASTListGenerateType1 import *
from ASTNames import *
from ASTNamespace import *
from ASTOperator import *
from ASTRankSpecs import *
from ASTSimpleExprs import *
from ASTTemplateList import *
from ASTType import *
from ASTUse import *
from ASTVal import *
from ASTVar import *
from ASTWord import *
from ASTBlock import *
from ASTIndexing import *
from ASTSet import *
from ASTCase import *
from ASTCases import *
from ASTPatternMatch import *
from ASTTrue import *
from ASTFalse import *
from ASTReturn import *
from ASTWrap import *
from mangle import *

import copy

basic_type = {'char': 0, 'int': 0, 'float': 0, 'double': 0}

#class SymbolInfo:
#  def __init__(self, val):
#    info = {}
#    for key in val:
#      info["@" + key] = val[key]
#    self.info = info
#
#  def get_info(self, keyword):
#    true_name = "@" + keyword
#    if self.info.has_key(true_name):
#      return self.info[true_name]
#    return None

def make_keys(target, keys, value):
  if target == None:
    target = {}
  elif not isinstance(target, dict):
    print "target variable is not dict"
    sys.exit(-1)

  cursor = target
  for key in keys[:-1]:
    if cursor.has_key(key):
      cursor = cursor[key]
    else:
      cursor[key] = {}
      cursor = cursor[key]

  key = keys[-1]
  cursor[key] = value

class SymbolTable:
  def __init__(self):
    self.alias     = {}
    self.hierarchy = {}
    self.reverse   = {}

    self.symtbl    = {}

  def reg_symbol(self, info):
    #print info.get_info('type')
    
    # alias is also class
    if info["@type"] == 'alias':
      name = info["@alias"]
      real = info["@target"]
      self.alias[name] = {"@type": "alias", "@original": info["@target"]}
      isloaded = self.search(real)
      if not isloaded:
        self.load_symbol_info(real)
    else:
      full = info["@long"]
      make_keys(self.hierarchy, full, info)
    
      reverse_token = full[:]
      reverse_token.reverse()
      make_keys(self.reverse, reverse_token, info)

  """ load symbol informations from file """
  def load_symbol_info(self, name):
    pass

  def search(self, name):
    tmp = name
    if isinstance(name, str):
      tmp = name.split('.')

    if len(tmp) == 1:
      if self.alias.has_key(tmp):
        tmp = self.alias[tmp].strip().split()

    node = self.hierarchy
    for item in tmp:
      if node.has_key(item):
        node = node[item]
      else:
        return None

    # node의 타입을 얻습니다. 
    if not node.has_key('@type'):
      return {'type': 'namespace'}

    return {'type': node['@type'], 'value': node}
      
  def walk_node(self, path, now, ret):
    if now.has_key('@type'):
      _ret = path[:]
      _ret.reverse()
      ret.append(_ret)
      return 

    for key in now:
      if key[0] == '@': 
        continue
      
      new_path = path + [key]
      self.walk_node(path = new_path, now = now[key], ret = ret)

symbol_dict = SymbolTable()

class Parser:
  def __init__(self, fn):
    self.isdebug = True

    self.token  = Token(fn)
 
    # for namespace
    self.now_scope = []
    self.property  = []    
    self.token.nextToken()

  def parse(self):
    context = []
    while self.token.tok != None:
      tree = None
    	
      value = self.token.tok.value
      if value == 'namespace':
        tree = self.parseNamespace()
      elif value == 'template':
        tree = self.parseTemplate()
      elif value == 'class':
        tree = self.parseClass()
      elif value == 'use' \
        or value == 'import':
        self.parseUse()
      elif value == 'def':
        tree = self.parseDefFunc()
      elif value == 'var':
        tree = self.parseDefVar(context = None)
      elif value == 'val':
        tree = self.parseDefVal(context = None)
      elif value == '@':
      	# parseAttribute
      	pass
      elif value == 'native':
      	self.token.match(value)
      	self.property.append(value)
      else:
        break

      if tree != None:
        context.append(tree)

    return context

  def parseNamespace(self):
    if not self.token.match('namespace'):
      return None

    old_scope         = self.now_scope

    names = self.parseNames(limitLen = 0)
    if len(self.now_scope) == 0:
      self.now_scope = names.array
    else:
      self.now_scope = self.now_scoop + names.array

    content = None
    if not self.token.match(';'):
      self.token.match('{')
      content = self.parse()
      self.token.match('}')

    ret_tree = ASTNamespace(ASTNames(self.now_scope), content)

    self.now_scope     = old_scope
    return ret_tree

  def parseTemplate(self):
    if not self.token.match('template'):
      return None

    type_info = {"@type": "template"}

    args = self.parseTemplateDefArgs()
    if tmpl == None or len(tmpl) == 0:
      print "Error) Need more template arguments"
      sys.exit(-1)

    # will change regular expression 
    postfix = "".join(map(lambda x: "".join(["?", x]), tmpl))

    tree = None

    value = self.token.tok.value
    if value == 'template':
      tree = self.parseTemplate()
    elif value == 'class':
      tree = self.parseClass()
    elif value == 'def':
      tree = self.parseDefFunc()
    elif value == 'var':
      tree = self.parseDefVar()
    elif value == 'val':
      tree = self.parseDefVal()

    return ASTTemplate(args, tree, type_info = type_info)

  def parseTemplateDefArgs(self):
    if not self.token.match('<'):
      return None

    items = []
    
    while True:
      self.token.match('class')
      name = self.parseNames(limitLen = 1)
      if name[0] in items:
        print "duplicated template name"
        sys.exit(-1)
      else:
        items.append(name[0])
        if not self.token.match(','):
          break
    
    self.token.match('>')
    return items

  def parseClass(self):
    if not self.token.match('class'):
      return None

    type_info = {"@type": "class"}

    cname = self.parseNames(limitLen = 0)
    fname = self.now_scope + cname.array

    if len(cname.array) == 1:
      type_info['@short'] = cname.array[0]
    else:
      type_info["@short"] = ".".join(cname.array[-1])
    type_info["@long"] = fname
    
    type_info["@property"] = self.property
    self.property = []

    symbol_dict.reg_symbol(type_info)
  
    # 단순히 정의만...
    # class xxx.xxx.xxx;
    if self.token.match(';'):
      return ASTClass(type_info)

    # 상속 
    if self.token.match(':'):
      level = self.token.tok.value

      if level != 'public' and level != 'protected' and level != 'private':
        print "Error) We didn't want '%s'" % level
        sys.exit(-1)
      
      self.token.nextToken()

      oname = self.parseNames(limitLen = 0)
      lst   = symbol_dict.search(oname.array)
      if lst == None:
        print "Not found that symbol"
        exit(-1)

      if lst['type'] != 'class':
        print "You must use class instead of %s" % (lst['type'])
        exit(-1)

      type_info["@parent"] = lst['value']

    self.token.match('{')
    type_info['@children'] = {}
    self.parseClassBody(type_info)
    self.token.match('}')

    return ASTClass(type_info)

  def parseClassBody(self, context):
    level = "public"

    while True:
      _info = None
      value = self.token.tok.value
      if value == 'public':
        self.token.match('public')
        self.token.match(':')
        level = "public"
      elif value == 'private':
        self.token.match('private')
        self.token.match(':')
        level = "private"
      elif value == 'protected':
        self.token.match('protected')
        self.token.match(':')
        level = 'protected'
      elif value == 'def':
        _info = self.parseDefFuncAtClass(context)
      elif value == 'var':
        _info = self.parseDefVarAtClass(context)
      elif value == 'val':
        _info = self.parseDefValAtClass(context)
      else:
        break

      if _info != None:
        _info['@level'] = level

  def parseUse(self):
    if not self.token.match('use') \
      and not self.token.match('import'):
      return

    # in general
    # use <external namespace>;
    names = self.parseNames(limitLen = 0)
    _name  = ".".join(names.array)

    # to load namespace information
    # however, ...
    type_info = {
      "@type" : "class",
      "@long" : names.array,
      "@short": names.array[-1]}
    symbol_dict.reg_symbol(type_info)
 
    if self.token.match('='):
      # use <external namespace> = <alias name>;
      alias = self.parseNames(limitLen = 1)
      self.token.nextToken(';')
      _alias = "".join(alias.array)
      if self.reverse_stack.has_key(alias[0]):
        self.reverse_stack[alias[0]].append(names.array)
      else:
        self.reverse_stack[alias[0]] = [names.array]

      type_info = {
        "@type"  : "alias",
        "@alias" : names.array[-1],
        "@long"  : [names.array[-1]],
        "@target": ".".join(names.array)}
      symbol_dict.reg_symbol(type_info)

    self.token.match(';')
  
  def parseNames(self, limitLen = 1):
    if self.token.match('_'):
      return ASTNames(['_'])
    elif self.token.tok.type != 'id':
      return None

    history = [self.token.tok.value]
    self.token.nextToken()
    if self.token.tok.value == '.' and limitLen == 1:
      print "we just needed one word!"
      sys.exit(-1)

    while self.token.match('.'):
      history.append(self.token.tok.value)
      self.token.nextToken()

    return ASTNames(history)

  def search_type(self, type):
    name  = type.name
    templ = type.templ
    ranks = type.ranks

    lst   = symbol_dict.search_from_last(name)
    if lst == None: return False

    return True

  def convert_to_str(self, type):
    def __inner(__templ):
      if __templ == None:
        return None

      str = None
      for item in _templ.history:
        str  = '<'
        str += self.convert_to_str(item)
        str += '>'
        
      return str
      
    name  = ".".join(type.name)
    templ = __inner(type.templ)
    ranks = None
    if type.ranks != None:
      for item in type.ranks.history:
        ranks += '[]'

    return "".join([name, templ, ranks])
 
  def parseDefFunc(self):
    if not self.token.match('def'):
      return None

    type_info = {}

    type_info['@type']     = 'function'
    type_info['@property'] = []

    # to make full path
    name = self.parseNames(limitLen = 0)
   
    type_info['@short'] = name.array[-1]
    type_info['@long'] = name.array
    
    self.token.match('(')
    args  = self.parseFuncArgsList()
    self.token.match(')')
    
    args_info = {}
    for item in args.history:
      if isinstance(item, ASTEmpty):
        break
      elif isinstance(item, ASTSet):
        # 이거에 대해서는 아직 결정된바가 없다.
        pass
      elif isinstance(item, ASTArgItem):
        name = item.name.array[0]
        # 1. name 중복성 체크
        if args_info.has_key(name):
          print "duplicated name at argument list : %s" % (name)
          sys.exit(-1)
       
        # 2. 그 다음 type의 symbol check : argument parsing을 할때 검사했기에
        # 3. 만들기
        args_info[name] = item.type

    type_info["@arguments"] = args_info

    # 일단 template 제외
    print type_info['@long']
    print type_info['@arguments']

    type_info['@symbol'] = encodeSymbolName(type_info['@long'], type_info['@arguments'])
    
    type  = None
    if self.token.match(':'):
      type = self.parseType()
      type_info["@rettype"] = type

    if not self.token.match(';'):
      body  = None
      if self.token.match('='):
        body  = self.parseExpr()
      elif self.token.match('{'):
        body  = self.parseExprs()
        self.token.match('}')

      type_info["@body"] = body
    else:
      type_info["@body"] = None

    symbol_dict.reg_symbol(type_info)
    print symbol_dict.hierarchy
    return type_info


  def parseDefFuncAtClass(self):
    if not self.token.match('def'):
      return None

    type_info = {}

    type_info['@type']     = 'function'
    type_info['@property'] = []

    # to make full path
    _tmp = self.parseNames(limitLen = 1)
    if _tmp.array[0] == '~':
      type_info['@type'] = 'destructor'
      _tmp = self.parseNames(limitLen = 1)

    path = _tmp.array[0]
    # 생성자인지 채크한다. 
    cls_name = context['@short']
    if cls_name == _tmp.array[0]:
      type_info['@type'] = 'constructor'
    #elif _tmp.array[0] == '+':
    #  pass

    type_info["@short"] = path
    type_info["@long"] = context['@long'] + [path]

    self.token.match('(')
    args  = self.parseFuncArgsList()
    self.token.match(')')
    
    args_info = {}
    for item in args.history:
      if isinstance(item, ASTEmpty):
        break
      elif isinstance(item, ASTSet):
        # 이거에 대해서는 아직 결정된바가 없다.
        pass
      elif isinstance(item, ASTArgItem):
        name = item.name.array[0]
        # 1. name 중복성 체크
        if args_info.has_key(name):
          print "duplicated name at argument list : %s" % (name)
          sys.exit(-1)
       
        # 2. 그 다음 type의 symbol check : argument parsing을 할때 검사했기에
        # 3. 만들기
        args_info[name] = item.type

    type_info["@arguments"] = args_info

    # 일단 template 제외
    print type_info['@long']
    print type_info['@arguments']

    type_info['@symbol'] = encodeSymbolName(type_info['@long'], type_info['@arguments'])
    
    type  = None
    if self.token.match(':'):
      type = self.parseType()
      type_info["@rettype"] = type

    if not self.token.match(';'):
      body  = None
      if self.token.match('='):
        body  = self.parseExpr()
      elif self.token.match('{'):
        body  = self.parseExprs()
        self.token.match('}')

      type_info["@body"] = body
    else:
      type_info["@body"] = None

    symbol_dict.reg_symbol(type_info)
    print symbol_dict.hierarchy
    return type_info

  def parseDefInnerFunc(self):
    if not self.token.match('def'):
      return None

    type_info = {}

    type_info['@type']     = 'function'
    type_info['@property'] = []

    # to make full path
    _tmp = self.parseNames(limitLen = 1)
    path = _tmp.array[0]
    type_info['@property'].append('lambda')
    type_info["@name"] = path

    self.token.match('(')
    args  = self.parseFuncArgsList()
    self.token.match(')')
    
    args_info = {}
    for item in args.history:
      if isinstance(item, ASTEmpty):
        break
      elif isinstance(item, ASTSet):
        # 이거에 대해서는 아직 결정된바가 없다.
        pass
      elif isinstance(item, ASTArgItem):
        name = item.name.array[0]
        # 1. name 중복성 체크
        if args_info.has_key(name):
          print "duplicated name at argument list : %s" % (name)
          sys.exit(-1)
       
        # 2. 그 다음 type의 symbol check : argument parsing을 할때 검사했기에
        # 3. 만들기
        args_info[name] = item.type

    type_info["@arguments"] = args_info
    
    type  = None
    if self.token.match(':'):
      type = self.parseType()
      type_info["@rettype"] = type

    body  = None
    if self.token.match('='):
      body  = self.parseExpr()
    elif self.token.match('{'):
      body  = self.parseExprs()
      self.token.match('}')

    type_info["@body"] = body
    
    return ASTDeclFunc(type_info)

  def parseFuncArgsList(self):
    history = []
    while True:
      isset = False
      if self.token.match('*'): 
        isset = True

      name = self.parseNames(limitLen = 1) 
      if name == None:
        history.append(ASTEmpty())
        break

      if isset:
        history.append(ASTSet([name]))
      else:
        self.token.match(':')
        type = self.parseType()
        history.append(ASTArgItem(name, type))

      if not self.token.match(','): break
    return ASTArgList(history)
      
  def parseType(self):
    names = self.parseNames(limitLen = 0)
    tmpl  = self.parseTemplatePart()
    #ename, body = symbol_dict.search(names.array)
    #if ename == None:
    #  print "doesn't exist symbol : %s" % (".".join(names.array))
    #  sys.exit(-1) # 일단 죽이고... 나중에 에러처리 생각
    #else:
    #  names.array = ename

    rank  = self.parseRankList()
    return ASTType(names, tmpl, rank)

  def parseTemplatePart(self):
    if not self.token.match('<'):
      return None

    ret = self.parseTemplateArgs()
    self.token.match('>')
    return ret

  def parseTemplateArgs(self):
    history = [self.parseType()]
    while self.token.match(','):
      history.append(self.parseType())
    return ASTTemplateList(history)

  def parseRankList(self):
    history = None
    while self.token.match('['):
      history.append(ASTEmpty())
      self.token.match(']')
    return history

  def parseExprs(self):
    history = []
    while True:
      tree = self.parseExpr()
      if tree == None: break
      history.append(tree)

    return ASTExprs(history)

  def parseExpr(self):
    which = self.token.tok.value
    ret = None
    if which == 'if':
      ret = self.parseIfStmt()
    elif which == 'for':
      ret = self.parseForStmt()
    elif which == 'var':
      ret = self.parseDefInnerVar()

      #realname = ret.name[0]
      #if self.findAt(tbl = self.local_symtbl, target = realname):
      #  print "duplicated name : %s" % (realname)
      #  sys.exit(-1)

      ## to check type
      #typename = convertType(ret.type)
      #if self.validateType(typename) == False:
      #  print "no type!"
      #  sys.exit(-1)

      #self.local_symtbl[realname] = {"attribute": None, "type": typename}
      ## 해당 Type에 assign operator가 있는지 확인
      #if ret.code != None:
      #  rname = self.makeMethodName(type, '=')
      #  if response != None:
      #    ret = ASTFuncCall(rname, ret.code)
      #  else:
      #    print "no method!"
      #    sys.exit(-1) # 일단 무조건 죽이고 본다.
      #else:
      #  ret = ASTEmpty()
    elif which == 'val':
      ret = self.parseDefInnerVal()

      #realname = ret.name[0]
      #if self.findAt(tbl = self.local_symtbl, target = realname):
      #  print "duplicated name : %s" % (realname)
      #  sys.exit(-1)

      ## to check type
      #typename = convertType(ret.type)
      #if self.validateType(typename) == False:
      #  print "no type!"
      #  sys.exit(-1)

      #self.local_symtbl[realname] = {"attribute": ["readonly"], "type": typename}
      ## 해당 Type에 assign operator가 있는지 확인
      #if ret.code != None:
      #  rname = self.makeMethodName(type, '=')
      #  if response != None:
      #    ret = ASTFuncCall(rname, ret.code)
      #  else:
      #    print "no method!"
      #    sys.exit(-1) # 일단 무조건 죽이고 본다.
      #else:
      #  ret = ASTEmpty()
    elif which == '{':
      ret = self.parseBlockExprs()
    else:
      ret = self.parseSimpleExpr1()
      if ret == None: return None

    return ASTExpr(ret)

  def parseSimpleExpr1(self):
    ret = self.parseSimpleExprs()
    if self.token.match('?'):
      body = self.parseMatchingCases()
      ret  = ASTPatternMatch(cond = ret, body = body)
    if ret == None: return None
    return ret
 
  def parseIfStmt(self):
    if not self.token.match('if'):
      return None

    cond = self.parseExpr()
    self.token.match(':')
    body = self.parseExpr()
    return ASTIf(cond, body)

  def parseForStmt(self):
    if not self.token.match('for'):
      return None

    cond = self.parseExpr()
    self.token.match(':')
    body = self.parseExpr()
    return ASTFor(cond, body)

  def parseDefVar(self):
    if not self.token.match('var'):
      return None

    name = self.parseNames(limitLen = 1)
    if not isLambda:
      name = self.now_scope + name

    self.token.match(':')
    type = self.parseType()
    init = None
    if self.token.match('='):
      init = self.parseExpr()
    return ASTVar(name, type, init)

  def parseDefVal(self):
    if not self.token.match('val'):
      return None

    name = self.parseNames(limitLen = 1)
    #if not isLambda:
    #  name = self.now_scope + name

    self.token.match(':')
    type = self.parseType()
    init = None
    if self.token.match('='):
      init = self.parseExpr()

    return ASTVal(name, type, init)

  def parseDefInnerVar(self):
    if not self.token.match('var'):
      return None

    name = self.parseNames(limitLen = 1)
    if not isLambda:
      name = self.now_scope + name

    self.token.match(':')
    type = self.parseType()
    init = None
    if self.token.match('='):
      init = self.parseExpr()
    return ASTVar(name, type, init)

  def parseDefInnerVal(self):
    if not self.token.match('val'):
      return None

    name = self.parseNames(limitLen = 1)
    #if not isLambda:
    #  name = self.now_scope + name

    self.token.match(':')
    type = self.parseType()
    init = None
    if self.token.match('='):
      init = self.parseExpr()

    return ASTVal(name, type, init)

  def parseBlockExprs(self):
    if not self.token.match('{'):
      return None
    body = self.parseExprs()
    self.token.match('}')
    return ASTBlock(body)

  def parseSimpleExprs(self):
    history = []
    while True:
      tree = self.parseSimpleExpr()
      if tree == None: break
      if self.token.tok.value == ',':
        hist = [tree]
        while self.token.match(','):
          tree = self.parseSimpleExpr()
          hist.append(tree)
        tree = ASTSet(hist)
      history.append(tree)

    if len(history) == 0: return None
    self.token.match(';') # caution!!
    return ASTSimpleExprs(history)

  def searchSymbolInLocal(self, name):
    # search at argument symbol list
    if len(self.argumentSymbolTbl) != 0:
      if self.argumentSymbolTbl.has_key(name):
        return convertType(self.argumentSymbolTbl[name])
    # search at local symbol list
    if len(self.localSymbolTbl) != 0:
      if self.localSymbolTbl.has_key(name):
        return convertType(self.localSymbolTbl[name])
    # search at global symbol list
    if len(self.symtbl) != 0:
      return None

    return None
    
  def parseSimpleExpr(self):
    tree = self.parseBasicSimpleExpr()
    if tree == None: return None
    while True:
      tok = self.token.tok
      if self.token.match('.'):
        right = self.parseBasicSimpleExpr()
        if isinstance(tree, ASTWord):
          if isinstance(right, ASTWord):
            tree = ASTNames([tree.value, right.value])
          elif isinstance(right, ASTFuncCall):
            tree = ASTFuncCall(ASTNames([tree.value, right.name.value]), right.body)
          elif isinstance(right, ASTIndexing):
            tree = ASTIndexing(ASTNames([tree.value, right.name.value]), right.history)
        elif isinstance(tree, ASTNames):
          if isinstance(right, ASTWord):
            tree = ASTNames(tree.array + [right.value])
          elif isinstance(right, ASTFuncCall):
            tree = ASTFuncCall(ASTNames(tree.array + [right.name.value]), right.body)
          elif isinstance(right, ASTIndexing):
            tree = ASTIndexing(ASTNames(tree.array + [right.name.value]), right.history)
        else:
          tree = ASTOperator(ASTWord(tok.type, tok.value), tree, right)
      elif tok.type == 'id':
        #if isinstance(tree, ASTSet):
        #  #if len(tree.lst) != 1:
        #  #  print "error!!" # make error!!
        #  if self.check_type(tree.lst[0]):
        #    tree = ASTCasting(tree.lst[0], ASTWord(tok.type, tok.value))
        self.token.nextToken()
        right = self.parseBasicSimpleExpr()
        tree = ASTOperator(ASTWord(tok.type, tok.value), tree, right)
      else:
        break

    return tree

  def parseBasicSimpleExpr(self):
    tok = self.token.tok
    if tok.type == 'stringLiteral': 
      self.token.nextToken()
      return ASTWord('System.lang.String', tok.value)
    elif tok.type == 'integerLiteral':
      self.token.nextToken()
      return ASTWord('System.lang.Integer', tok.value)
    elif tok.type == 'floatLiteral':
      self.token.nextToken()
      return ASTWord('System.lang.Float', tok.value)
    elif self.token.match('true'):
      return ASTWord('System.lang.Boolean', '1')
    elif self.token.match('false'):
      return ASTWord('System.lang.Boolean', '0')
    elif self.token.match('return'):
      return ASTReturn(self.parseExpr())
    elif tok.value == 'def':
      ret = self.parseDefInnerFunc()

      #if len(ret.name) != 1:
      #  print "don't use namespace!"
      #  sys.exit(-1)

      #realname = ret.name[0]
      #if realname == '_':
      #  realname = self.genTemporaryName()  
      #if self.findAt(tbl = self.local_symtbl, target = ret.name):
      #  print "already defined!"
      #  sys.exit(-1)

      #typename = convertType(ret.ret)
      #if not self.validateType(typename):
      #  print "not declare type"
      #  sys.exit(-1)
      
      #self.local_symtbl[realname] = {
      #  "attribute": ["lambda"], 
      #  "args": ret.args, 
      #  "type": typename, 
      #  "body": ret.body}

      return ret
    elif tok.type == 'id':
      self.token.nextToken()
      if self.token.tok.value == '[':
        history = []
        while self.token.match('['):
          history.append(self.parseSimpleExpr())
          self.token.match(']')
        return ASTIndexing(ASTWord(tok.type, tok.value), history)
      elif self.token.match('('):
        args = self.parseArgumentList()
        self.token.match(')')
        return ASTFuncCall(ASTWord(tok.type, tok.value), args)
      else:
        return ASTWord(tok.type, tok.value)
    elif tok.value == '_':
      self.token.nextToken()
      return ASTWord('v', tok.value)
    elif tok.value == '[':
      self.token.match('[')
      history = []
      tree = self.parseSimpleExpr()
      if self.token.match('...'):
        right = self.parseSimpleExpr()
        self.token.match(']')
        return ASTListGenerateType1(tree, right)
      elif self.token.tok.value == ',':
        history.append(tree)
        while self.token.match(','):
          item = self.parseSimpleExpr()
          history.append(item)
        self.token.match(']')
        return ASTListValue(history)
       
      self.token.match(']')
      return ASTListValue([tree])
    elif tok.value == '(':
      self.token.match('(')
      tree = self.parseSimpleExpr1()
      self.token.match(')')
      return ASTWrap(tree)

    return None

  def parseArgumentList(self):
    # 인자로 if나 for문이 올 수 있다면 아래것 그대로 사용하면 ㅇㅋ,
    # 하지만 그렇지 않다면...
    tree = self.parseExpr()
    if tree == None: return None

    history = [tree]
    while self.token.match(','):
      history.append(self.parseExpr())

    return ASTArgList(history)

  def parseMatchingCases(self):
    history = []
    while True:
      left = self.parseSimpleExpr()
      self.token.match('=>')
      right = self.parseSimpleExpr()
      if self.token.match(';'): break
      history.append(ASTCase(left, right))
      self.token.match(',')

    return ASTCases(history)

class IntermediateRuntimeCode:
  def __init__(self, symtbl):
    self.symtbl = symtbl
    self.stack_of_var = {}
    self.stack_of_fun = {}

    self.ir = IR()

  def convert(self):
    for key in self.symtbl:
      cursor = self.symtbl[key]
      type   = cursor["type"]
      if type == "variable":
        self.reserve_space(key, cursor["body"])
      elif type == "value":
        self.reserve_constant_space(key, cursor["body"])
      elif type == "function":
        self.process_function(key, cursor["body"])

  def reserve_space(self, name, body):
    type = body.type
    tname = ".".join(type.name.array)
    if tname == "int" \
      or tname == "uint":
      self.ir.define_var(name, "dd")

  def reserve_constant_space(self, name, body):
    type  = body.type
    tname = ".".join(type.name.array)

  def process_function(self, name, body):
    real_body = body.body
    if isinstance(real_body, ASTExprs):
      for item in real_body.exprs:
        self.process_expr(item)
    elif isinstance(real_body, ASTExpr):
      self.process_expr(real_body.expr)

  def process_expr(self, body):
    if isinstance(body, ASTIfStmt):
      return None
    elif isinstance(body, ASTForStmt):
      return None
    elif isinstance(body, ASTDefVar):
      return None
    elif isinstance(body, ASTDefVal):
      return None
    elif isinstance(body, ASTBlock):
      exprs = body.exprs
      for item in exprs.exprs:
        self.process_expr(item)
    else:
      return None

def convertIntToHex(value):
  string = str(value)
  if string[:2] == '0x':
    return hex(int(string[2:], 16))
  elif string[0] == '0':
    try:
      return hex(int(string, 8))
    except:
      return hex(int(string))
  else:
    return hex(int(string))

  return None

def convertFloatToHex(value):
  string = str(value)
  return None

# 아래 코드는 수정할 예정임  
class Transformation:
  def __init__(self, symtbl):
    self.symtbl = symtbl
    self.arg_symtbl   = {}
    self.local_symtbl = {}
    self.local_constant_symtbl = {}
    self.stringtbl    = []

  def convert(self):
    for key in self.symtbl:
      ast = self.symtbl[key]
      if isinstance(ast, ASTDeclFunc):
        # local 변수 Stack 필요.
        continue
      elif isinstance(ast, ASTDefVar):
        continue
      elif isinstance(ast, ASTDefVal):
        continue

  # search the symbol and return type of it.
  def searchSymbolTable(self, name):
    if self.arg_symtbl.has_key(name):
      return self.arg_symtbl[name]
    elif self.local_symtbl.has_key(name):
      return self.local_symtbl[name]
    elif self.local_constant_symtbl.has_key(name):
      return self.local_constant_symtbl[name]

    return None

  def processExpr(self):
    now = self.now
    if isinstance(now, ASTOperator):
      left  = self.transform(now.left)
      right = self.transform(now.right)
      # to construct
    if isinstance(now, ASTWord):
      if now.type == 'integerLiteral':
        convstr = convertIntToHex(now.value)
        typestr = ""
        if len(convstr) <= 2:
          typestr = "integer2"
        elif len(convstr) <= 4:
          typestr = "integer4"
        elif len(convstr) <= 8:
          typestr = "integer8"
        elif len(convstr) <= 16:
          typestr = "integer16"
        else:
          typestr = "number"

        return {"type": typestr, "value": convstr}
      elif now.type == 'floatLiteral':
        convstr = convertFloatToHex(now.value)
        return {"type": "float8", "value": convstr}
      elif now.type == 'stringLiteral':
        index = len(self.stringtbl)
        self.stringtbl.append(now.value)
        return {"type": "string", "index": index}
      elif now.type == 'id':
        regnum = len(self.symboltbl)
        # 단일이면 register, 크기가 있다면 start address를 register
        type   = self.searchSymbol(now.value)
        if self.isBasicType(type):
          return {"type": type, "register-num": regnum}
        else:
          return {"type": type, "register-num": regnum, "extendtype": "indrect"}
      else:
        print "I don't know how the ASTWord(%s) convert" % (now.name)
      return None
    elif isinstance(now, ASTVar):
      if self.searchSymbol(now.name) == None:
        print "duplicate symbol"
      self.local_symtbl[now.name] = convertType(now.type)
      ret = self.parseExpr(now.init)
    elif isinstance(now, ASTVal):
      if self.searchSymbol(now.name) == None:
        print "duplicate symbol"
      self.local_constant_symtbl[now.name] = now.type
      ret = self.parseExpr(now.init)

parser = Parser("sample.prg")
parser.parse()
#print parser.symbol_dict.hierarchy
#for key in parser.symbol_dict.hierarchy:
#  print key

def makeSymbolName(cname, fname, args):
  print "debug) %s, %s" % (cname, fname)

  name = [cname, str(len(fname)), fname, convertType(args)]
  print "debug) full : %s" % ("".join(name))
  return "".join(name)

class IR:
  def __init__(self):
    self.content = []
    self.random  = Random()

  def getType(self, node):
    if node is ASTWord:
      type = None
      if node.type is str:
        type = node.type.split('.')
      else:
        # not yet
        type = node.array

      return convertName(type)
    elif node is ASTNames:
      return convertName(self.array)
    else:
      print "Error in getType"

  def searchFuncInClass(cname, fname, args):
    symbol = makeSymbolName(cname, fname, args)
    ret    = symbol_dict.search(symbol)
    if ret == None: return False
    return True

  def findSymbolType(self, tree):
    return self.getType(tree)

  def genRandomVariable(self, ret_type):
    basestr = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"
    name = "__" + "".join([basestr[self.random.randrange(0, len(basestr))] for i in range(0, 10)])
    return {'@name': name,
            '@type': ret_type,
            '@representation': 'identifier'}

  def evalFunc(self, tree):
    if not isinstance(tree, ASTDeclFunc):
      info = {'@argument_symbols': {}}

      args = tree.info['@arguments']
      for var_name in args:
        info['@argument_symbols'][var_name] = args[var_name]

      print "argument = ", info['@argument_symbols']
      sys.exit(-1)

  def eval(self, tree):
    innerSymbolTbl = {}
    while True:
      print tree
      if isinstance(tree, ASTDeclFunc):
        self.evalFunc(tree)
      elif isinstance(tree, ASTWord):
        if tree.type == 'id':
          # find at symbol table of function
          ret = None
          type = self.findSymbolType(tree.value)
          return {"@name": tree.value, 
                  "@type": convertName(type), 
                  "@representation": 'identifier'}
        else:
          return {"@name": tree.value, 
                  "@type": convertName(tree.type.split('.')),
                  "@representation": 'value'}
      elif isinstance(tree, ASTExprs):
        for subtree in tree.exprs:
          self.eval(subtree)
      elif isinstance(tree, ASTExpr):
        self.eval(tree.expr)
      elif isinstance(tree, ASTSimpleExprs):
        for expr in tree.exprs:
          self.eval(expr)
      elif isinstance(tree, ASTOperator):
        ltype = self.eval(tree.left)
        rtype = self.eval(tree.right)

        func  = self.searchFuncInClass(cname = ltype['@type'], fname = tree.name, args = [rtype['@type']])
        if func == None:
          # if fname is None, fname will be the class name.
          casting_func = self.searchFuncInClass(cname = ltype['@type'], fname = None, args = [rtype['@type']])
          if casting_func == None:
            print "Compiler doesn't know how to convert %s into %s" % (recoverName(ltype), recoverName(rtype))
            sys.exit(-1)

          tmpval = self.genRandomVariable(casting_func['@return'])
          IR.emitCall(casting_func['@name'], args = [rtype['@name']], retval = tmpval['@name'])
          rtype  = tmpval
          
          func   = self.searchFuncInClass(cname = ltype['@type'], fname = tree.name, args = [rtype['@type']])
        
        tmpval = self.genRandomVariable(func['@return'])
        IR.emitCall(func['@name'], args = [ltype['@name'], rtype['@name']], retval = tmpval['@name'])

        return tmpval
      else:
        if not tree.has_key('@type'):
          print tree
          break

        if tree['@type'] == 'function':
          info = {'@arguments': {}}

          for name in tree['@arguments']:
            info['@arguments'][name] = convertType(tree['@arguments'][name])

          info['@return'] = convertType(tree['@rettype'])

          print info['@arguments']
          print info['@return']

          self.eval(tree['@body'])
        else:
          break
ir = IR()
ir.eval(symbol_dict.hierarchy['add'])


