#!/usr/bin/env pythone
# -*- coding: utf-8 -*-
import traceback

from Token import *

from AST import *
from ASTAlias import *
from ASTArgItem import *
from ASTArgList import *
from ASTAttribute import *
from ASTTemplate import *
from ASTClass import *
from ASTDeclFunc import *
from ASTEmpty import *
from ASTExpr import *
from ASTExprs import *
from ASTFor import *
from ASTFuncCall import *
from ASTIf import *
from ASTListGenerateType1 import *
from ASTNames import *
from ASTNamespace import *
from ASTOperator import *
from ASTRankSpecs import *
from ASTSimpleExprs import *
from ASTTemplateList import *
from ASTType import *
from ASTUse import *
from ASTVal import *
from ASTVar import *
from ASTWord import *
from ASTBlock import *
from ASTIndexing import *
from ASTSet import *
from ASTCase import *
from ASTCases import *
from ASTPatternMatch import *
from ASTTrue import *
from ASTFalse import *
from ASTReturn import *
from ASTWrap import *
from mangle import *

import copy

basic_type = {'char': 0, 'int': 0, 'float': 0, 'double': 0}

#class TypeInfo:
#  def __init__(self, val):
#    info = {}
#    for key in val:
#      info["@" + key] = val[key]
#    self.info = info
#
#  def get_info(self, keyword):
#    true_name = "@" + keyword
#    if self.info.has_key(true_name):
#      return self.info[true_name]
#    return None

def make_keys(target, keys, value):
  if target == None:
    target = {}
  elif not isinstance(target, dict):
    print "target variable is not dict"
    sys.exit(-1)

  cursor = target
  for ind, item in enumerate(keys):
    if cursor.has_key(item):
      cursor = cursor[item]
    else:
      if ind + 1 == len(keys):
        break
      else:
        cursor[item] = {}
        cursor = cursor[item]

  cursor[item] = value

class SymbolTable:
  def __init__(self):
    self.alias     = {}
    self.hierarchy = {}
    self.reverse   = {}

    self.symtbl    = {}

  def reg_symbol(self, info):
    #print info.get_info('type')
    if info["@type"] == 'alias':
      name = info["@short"]
      full = info["@target"].split(".")
      self.alias[name] = full
      name, info = self.search(name)
      if name == None:
        self.load_symbol_info(name)
    else:
      full = info["@long"]
      make_keys(self.hierarchy, full, info)
    
      reverse_token = full[:]
      reverse_token.reverse()
      make_keys(self.reverse, reverse_token, info)

  """ load symbol informations from file """
  def load_symbol_info(self, name):
    pass

  def search(self, name):
    _name, _info = self.search_from_first(name)
    if _name == None:
      _name, _info = self.search_from_last(name)
    return (_name, _info)

  def search_from_first(self, name):
    target = []
    if isinstance(name, str):
      target = name.split('.')
    else:
      target = name
      
    # 우선 alias에서 먼저 찾고...
    if len(target) == 1:
      _name = target[0]
      if self.alias.has_key(_name):
        _type = self.alias[_name]
        return self.search(_type)

    cursor = self.hierarchy
    for item in target:
      if cursor.has_key(item):
        cursor = cursor[item]
      else:
        return (None, None)

    return (name, cursor)

  def search_from_last(self, name):
    target = []
    if isinstance(name, str):
      target = name.split('.')
    else:
      target = name

    cursor = self.reverse
    for item in target:
      if cursor.has_key(item):
        cursor = cursor[item]
      else:
        return (None, None)

    ret = []
    self.walk_node(path = target, now = cursor, ret = ret)
    if len(ret) == 0:
      return (None, None)

    return self.search_from_first(ret[0])

  def walk_node(self, path, now, ret):
    if now.has_key('@type'):
      _ret = path[:]
      _ret.reverse()
      ret.append(_ret)
      return 

    for key in now:
      if key[0] == '@': 
        continue
      
      new_path = path + [key]
      self.walk_node(path = new_path, now = now[key], ret = ret)

symbol_dict = SymbolTable()

class Parser:
  def __init__(self, fn):
    self.isdebug = True

    self.token  = Token(fn)
 
    # for namespace
    self.now_scope = []
    self.property  = []    
    self.token.nextToken()

  def parse(self):
    context = []
    while self.token.tok != None:
      tree = None
    	
      value = self.token.tok.value
      if value == 'namespace':
        tree = self.parseNamespace()
      elif value == 'template':
        tree = self.parseTemplate()
      elif value == 'class':
        tree = self.parseClass()
      elif value == 'use' \
        or value == 'import':
        self.parseUse()
      elif value == 'def':
        tree = self.parseDefFunc(context = None)
      elif value == 'var':
        tree = self.parseDefVar(context = None)
      elif value == 'val':
        tree = self.parseDefVal(context = None)
      elif value == '@':
      	# parseAttribute
      	pass
      elif value == 'native':
      	self.token.match(value)
      	self.property.append(value)
      else:
        break

      if tree != None:
        context.append(tree)

    return context

  def parseNamespace(self):
    if not self.token.match('namespace'):
      return None

    old_scope         = self.now_scope

    names = self.parseNames(limitLen = 0)
    if len(self.now_scope) == 0:
      self.now_scope = names.array
    else:
      self.now_scope = self.now_scoop + names.array

    content = None
    if not self.token.match(';'):
      self.token.match('{')
      content = self.parse()
      self.token.match('}')

    ret_tree = ASTNamespace(ASTNames(self.now_scope), content)

    self.now_scope     = old_scope
    return ret_tree

  def parseTemplate(self):
    if not self.token.match('template'):
      return None

    type_info = {"@type": "template"}

    args = self.parseTemplateDefArgs()
    if tmpl == None or len(tmpl) == 0:
      print "Error) Need more template arguments"
      sys.exit(-1)

    # will change regular expression 
    postfix = "".join(map(lambda x: "".join(["?", x]), tmpl))

    tree = None

    value = self.token.tok.value
    if value == 'template':
      tree = self.parseTemplate()
    elif value == 'class':
      tree = self.parseClass()
    elif value == 'def':
      tree = self.parseDefFunc()
    elif value == 'var':
      tree = self.parseDefVar()
    elif value == 'val':
      tree = self.parseDefVal()

    return ASTTemplate(args, tree, type_info = type_info)

  def parseTemplateDefArgs(self):
    if not self.token.match('<'):
      return None

    items = []
    
    while True:
      self.token.match('class')
      name = self.parseNames(limitLen = 1)
      if name[0] in items:
        print "duplicated template name"
        sys.exit(-1)
      else:
        items.append(name[0])
        if not self.token.match(','):
          break
    
    self.token.match('>')
    return items

  def parseClass(self):
    if not self.token.match('class'):
      return None

    type_info = {"@type": "class"}

    cname = self.parseNames(limitLen = 0)
    fname = self.now_scope + cname.array

    if len(cname.array) == 1:
      type_info['@short'] = cname.array[0]
    else:
      type_info["@short"] = ".".join(cname.array[-1])
    type_info["@long"] = fname
    
    type_info["@property"] = self.property
    self.property = []

    symbol_dict.reg_symbol(type_info)
  
    # 단순히 정의만...
    # class xxx.xxx.xxx;
    if self.token.match(';'):
      return ASTClass(type_info)

    # 상속 
    if self.token.match(':'):
      oname = self.parseNames(limitLen = 0)
      lst   = self.search_full_name(oname.array)
      if len(lst) == 0:
        print "not found parent's class : %s" % (".".join(oname.array))
        sys.exit(-1)
      if len(lst) != 1:
        print "duplicate symbol : %s" % (".".join(oname.array))
        sys.exit(-1)
      
      type_info["@parent"] = ".".join(lst[0])
      if self.is_debug:
        print type_info["@parent"]

    self.token.match('{')
    type_info['@children'] = {}
    self.parseClassBody(type_info)
    self.token.match('}')

    return ASTClass(type_info)

  def parseClassBody(self, context):
    level = "public"

    while True:
      _info = None
      value = self.token.tok.value
      if value == 'public':
        self.token.match('public')
        self.token.match(':')
        level = "public"
      elif value == 'private':
        self.token.match('private')
        self.token.match(':')
        level = "private"
      elif value == 'protected':
        self.token.match('protected')
        self.token.match(':')
        level = 'protected'
      elif value == 'def':
        _info = self.parseDefFunc(context)
      elif value == 'var':
        _info = self.parseDefVar(context)
      elif value == 'val':
        _info = self.parseDefVal(context)
      else:
        break

      if _info != None:
        _info['@level'] = level

  def parseUse(self):
    if not self.token.match('use') \
      and not self.token.match('import'):
      return

    # in general
    # use <external namespace>;
    names = self.parseNames(limitLen = 0)
    _name  = ".".join(names.array)

    # to load namespace information
    # however, ...
    type_info = {
      "@type" : "class",
      "@long" : names.array,
      "@short": names.array[-1]}
    symbol_dict.reg_symbol(type_info)
 
    if self.token.match('='):
      # use <external namespace> = <alias name>;
      alias = self.parseNames(limitLen = 1)
      self.token.nextToken(';')
      _alias = "".join(alias.array)
      if self.reverse_stack.has_key(alias[0]):
        self.reverse_stack[alias[0]].append(names.array)
      else:
        self.reverse_stack[alias[0]] = [names.array]

      type_info = {
        "@type"  : "alias",
        "@short" : names.array[-1],
        "@long"  : [names.array[-1]],
        "@target": ".".join(names.array)}
      symbol_dict.reg_symbol(type_info)

    self.token.match(';')
  
  def parseNames(self, limitLen = 1):
    if self.token.match('_'):
      return ASTNames(['_'])
    elif self.token.tok.type != 'id':
      return None

    history = [self.token.tok.value]
    self.token.nextToken()
    if self.token.tok.value == '.' and limitLen == 1:
      print "we just needed one word!"
      sys.exit(-1)

    while self.token.match('.'):
      history.append(self.token.tok.value)
      self.token.nextToken()

    return ASTNames(history)

  def search_type(self, type):
    name  = type.name
    templ = type.templ
    ranks = type.ranks

    lst   = symbol_dict.search_from_last(name)
    if lst == None: return False

    return True

  def convert_to_str(self, type):
    def __inner(__templ):
      if __templ == None:
        return None

      str = None
      for item in _templ.history:
        str  = '<'
        str += self.convert_to_str(item)
        str += '>'
        
      return str
      
    name  = ".".join(type.name)
    templ = __inner(type.templ)
    ranks = None
    if type.ranks != None:
      for item in type.ranks.history:
        ranks += '[]'

    return "".join([name, templ, ranks])
  
  def parseDefFunc(self, context):
    if not self.token.match('def'):
      return None

    type_info = {}

    type_info['@type']     = 'function'
    type_info['@property'] = []

    # to make full path
    path = None
    if context == None:
      name = self.parseNames(limitLen = 0)
      path = self.now_scope + name.array
      
      type_info['@short'] = name.array[-1]
      type_info['@long'] = path
    else:
      _tmp = self.parseNames(limitLen = 1)
      path = _tmp.array[0]
      if context["@type"] == 'class':
        pass
      elif context["@type"] == 'function':
        if _tmp == '_':
          type_info['@property'].append('lambda')
        else:
          type_info['@property'].append('inner')

      type_info["@short"] = path
      type_info["@long"] = context['@long'] + [path]

    self.token.match('(')
    args  = self.parseFuncArgsList()
    self.token.match(')')
    
    args_info = {}
    for item in args.history:
      if isinstance(item, ASTEmpty):
        break
      elif isinstance(item, ASTSet):
        # 이거에 대해서는 아직 결정된바가 없다.
        pass
      elif isinstance(item, ASTArgItem):
        name = item.name.array[0]
        # 1. name 중복성 체크
        if args_info.has_key(name):
          print "duplicated name at argument list : %s" % (name)
          sys.exit(-1)
       
        # 2. 그 다음 type의 symbol check : argument parsing을 할때 검사했기에
        # 3. 만들기
        args_info[name] = item.type

    type_info["@arguments"] = args_info

    # 일단 template 제외
    type_info['@symbol'] = encodeSymbolName(type_info['@long'], type_info['@arguments'])
    
    type  = None
    if self.token.match(':'):
      type = self.parseType()
      type_info["@rettype"] = type

    if not self.token.match(';'):
      body  = None
      if self.token.match('='):
        body  = self.parseExpr()
      elif self.token.match('{'):
        body  = self.parseExprs()
        self.token.match('}')

      type_info["@body"] = body
    else:
      type_info["@body"] = None

    symbol_dict.reg_symbol(type_info)
    print symbol_dict.hierarchy
    return type_info

  def parseDefInnerFunc(self):
    if not self.token.match('def'):
      return None

    type_info = {}

    type_info['@type']     = 'function'
    type_info['@property'] = []

    # to make full path
    _tmp = self.parseNames(limitLen = 1)
    path = _tmp.array[0]
    type_info['@property'].append('lambda')
    type_info["@name"] = path

    self.token.match('(')
    args  = self.parseFuncArgsList()
    self.token.match(')')
    
    args_info = {}
    for item in args.history:
      if isinstance(item, ASTEmpty):
        break
      elif isinstance(item, ASTSet):
        # 이거에 대해서는 아직 결정된바가 없다.
        pass
      elif isinstance(item, ASTArgItem):
        name = item.name.array[0]
        # 1. name 중복성 체크
        if args_info.has_key(name):
          print "duplicated name at argument list : %s" % (name)
          sys.exit(-1)
       
        # 2. 그 다음 type의 symbol check : argument parsing을 할때 검사했기에
        # 3. 만들기
        args_info[name] = item.type

    type_info["@arguments"] = args_info
    
    type  = None
    if self.token.match(':'):
      type = self.parseType()
      type_info["@rettype"] = type

    body  = None
    if self.token.match('='):
      body  = self.parseExpr()
    elif self.token.match('{'):
      body  = self.parseExprs()
      self.token.match('}')

    type_info["@body"] = body
    
    return ASTDeclFunc(type_info)

  def parseFuncArgsList(self):
    history = []
    while True:
      isset = False
      if self.token.match('*'): 
        isset = True

      name = self.parseNames(limitLen = 1) 
      if name == None:
        history.append(ASTEmpty())
        break

      if isset:
        history.append(ASTSet([name]))
      else:
        self.token.match(':')
        type = self.parseType()
        history.append(ASTArgItem(name, type))

      if not self.token.match(','): break
    return ASTArgList(history)
      
  def parseType(self):
    names = self.parseNames(limitLen = 0)
    tmpl  = self.parseTemplatePart()
    #ename, body = symbol_dict.search(names.array)
    #if ename == None:
    #  print "doesn't exist symbol : %s" % (".".join(names.array))
    #  sys.exit(-1) # 일단 죽이고... 나중에 에러처리 생각
    #else:
    #  names.array = ename

    rank  = self.parseRankList()
    return ASTType(names, tmpl, rank)

  def parseTemplatePart(self):
    if not self.token.match('<'):
      return None

    ret = self.parseTemplateArgs()
    self.token.match('>')
    return ret

  def parseTemplateArgs(self):
    history = [self.parseType()]
    while self.token.match(','):
      history.append(self.parseType())
    return ASTTemplateList(history)

  def parseRankList(self):
    history = None
    while self.token.match('['):
      history.append(ASTEmpty())
      self.token.match(']')
    return history

  def parseExprs(self):
    history = []
    while True:
      tree = self.parseExpr()
      if tree == None: break
      history.append(tree)

    return ASTExprs(history)

  def parseExpr(self):
    which = self.token.tok.value
    ret = None
    if which == 'if':
      ret = self.parseIfStmt()
    elif which == 'for':
      ret = self.parseForStmt()
    elif which == 'var':
      ret = self.parseDefInnerVar()

      #realname = ret.name[0]
      #if self.findAt(tbl = self.local_symtbl, target = realname):
      #  print "duplicated name : %s" % (realname)
      #  sys.exit(-1)

      ## to check type
      #typename = convertType(ret.type)
      #if self.validateType(typename) == False:
      #  print "no type!"
      #  sys.exit(-1)

      #self.local_symtbl[realname] = {"attribute": None, "type": typename}
      ## 해당 Type에 assign operator가 있는지 확인
      #if ret.code != None:
      #  rname = self.makeMethodName(type, '=')
      #  if response != None:
      #    ret = ASTFuncCall(rname, ret.code)
      #  else:
      #    print "no method!"
      #    sys.exit(-1) # 일단 무조건 죽이고 본다.
      #else:
      #  ret = ASTEmpty()
    elif which == 'val':
      ret = self.parseDefInnerVal()

      #realname = ret.name[0]
      #if self.findAt(tbl = self.local_symtbl, target = realname):
      #  print "duplicated name : %s" % (realname)
      #  sys.exit(-1)

      ## to check type
      #typename = convertType(ret.type)
      #if self.validateType(typename) == False:
      #  print "no type!"
      #  sys.exit(-1)

      #self.local_symtbl[realname] = {"attribute": ["readonly"], "type": typename}
      ## 해당 Type에 assign operator가 있는지 확인
      #if ret.code != None:
      #  rname = self.makeMethodName(type, '=')
      #  if response != None:
      #    ret = ASTFuncCall(rname, ret.code)
      #  else:
      #    print "no method!"
      #    sys.exit(-1) # 일단 무조건 죽이고 본다.
      #else:
      #  ret = ASTEmpty()
    elif which == '{':
      ret = self.parseBlockExprs()
    else:
      ret = self.parseSimpleExpr1()
      if ret == None: return None

    return ASTExpr(ret)

  def parseSimpleExpr1(self):
    ret = self.parseSimpleExprs()
    if self.token.match('?'):
      body = self.parseMatchingCases()
      ret  = ASTPatternMatch(cond = ret, body = body)
    if ret == None: return None
    return ret
 
  def parseIfStmt(self):
    if not self.token.match('if'):
      return None

    cond = self.parseExpr()
    self.token.match(':')
    body = self.parseExpr()
    return ASTIf(cond, body)

  def parseForStmt(self):
    if not self.token.match('for'):
      return None

    cond = self.parseExpr()
    self.token.match(':')
    body = self.parseExpr()
    return ASTFor(cond, body)

  def parseDefVar(self):
    if not self.token.match('var'):
      return None

    name = self.parseNames(limitLen = 1)
    if not isLambda:
      name = self.now_scope + name

    self.token.match(':')
    type = self.parseType()
    init = None
    if self.token.match('='):
      init = self.parseExpr()
    return ASTVar(name, type, init)

  def parseDefVal(self):
    if not self.token.match('val'):
      return None

    name = self.parseNames(limitLen = 1)
    #if not isLambda:
    #  name = self.now_scope + name

    self.token.match(':')
    type = self.parseType()
    init = None
    if self.token.match('='):
      init = self.parseExpr()

    return ASTVal(name, type, init)

  def parseDefInnerVar(self):
    if not self.token.match('var'):
      return None

    name = self.parseNames(limitLen = 1)
    if not isLambda:
      name = self.now_scope + name

    self.token.match(':')
    type = self.parseType()
    init = None
    if self.token.match('='):
      init = self.parseExpr()
    return ASTVar(name, type, init)

  def parseDefInnerVal(self):
    if not self.token.match('val'):
      return None

    name = self.parseNames(limitLen = 1)
    #if not isLambda:
    #  name = self.now_scope + name

    self.token.match(':')
    type = self.parseType()
    init = None
    if self.token.match('='):
      init = self.parseExpr()

    return ASTVal(name, type, init)


  def parseBlockExprs(self):
    if not self.token.match('{'):
      return None
    body = self.parseExprs()
    self.token.match('}')
    return ASTBlock(body)

  def parseSimpleExprs(self):
    history = []
    while True:
      tree = self.parseSimpleExpr()
      if tree == None: break
      if self.token.tok.value == ',':
        hist = [tree]
        while self.token.match(','):
          tree = self.parseSimpleExpr()
          hist.append(tree)
        tree = ASTSet(hist)
      history.append(tree)

    if len(history) == 0: return None
    self.token.match(';') # caution!!
    return ASTSimpleExprs(history)

  def searchSymbolInLocal(self, name):
    # search at argument symbol list
    if len(self.argumentSymbolTbl) != 0:
      if self.argumentSymbolTbl.has_key(name):
        return convertType(self.argumentSymbolTbl[name])
    # search at local symbol list
    if len(self.localSymbolTbl) != 0:
      if self.localSymbolTbl.has_key(name):
        return convertType(self.localSymbolTbl[name])
    # search at global symbol list
    if len(self.symtbl) != 0:
      return None

    return None
    
  def parseSimpleExpr(self):
    tree = self.parseBasicSimpleExpr()
    if tree == None: return None
    while True:
      tok = self.token.tok
      if self.token.match('.'):
        right = self.parseBasicSimpleExpr()
        if isinstance(tree, ASTWord):
          if isinstance(right, ASTWord):
            tree = ASTNames([tree.value, right.value])
          elif isinstance(right, ASTFuncCall):
            tree = ASTFuncCall(ASTNames([tree.value, right.name.value]), right.body)
          elif isinstance(right, ASTIndexing):
            tree = ASTIndexing(ASTNames([tree.value, right.name.value]), right.history)
        elif isinstance(tree, ASTNames):
          if isinstance(right, ASTWord):
            tree = ASTNames(tree.array + [right.value])
          elif isinstance(right, ASTFuncCall):
            tree = ASTFuncCall(ASTNames(tree.array + [right.name.value]), right.body)
          elif isinstance(right, ASTIndexing):
            tree = ASTIndexing(ASTNames(tree.array + [right.name.value]), right.history)
        else:
          tree = ASTOperator(ASTWord(tok.type, tok.value), tree, right)
      elif tok.type == 'id':
        #if isinstance(tree, ASTSet):
        #  #if len(tree.lst) != 1:
        #  #  print "error!!" # make error!!
        #  if self.check_type(tree.lst[0]):
        #    tree = ASTCasting(tree.lst[0], ASTWord(tok.type, tok.value))
        self.token.nextToken()
        right = self.parseBasicSimpleExpr()
        tree = ASTOperator(ASTWord(tok.type, tok.value), tree, right)
      else:
        break

    return tree

  def parseBasicSimpleExpr(self):
    tok = self.token.tok
    if tok.type == 'stringLiteral': 
      self.token.nextToken()
      return ASTWord('System.lang.String', tok.value)
    elif tok.type == 'integerLiteral':
      self.token.nextToken()
      return ASTWord('System.lang.Integer', tok.value)
    elif tok.type == 'floatLiteral':
      self.token.nextToken()
      return ASTWord('System.lang.Float', tok.value)
    elif self.token.match('true'):
      return ASTWord('System.lang.Boolean', '1')
    elif self.token.match('false'):
      return ASTWord('System.lang.Boolean', '0')
    elif self.token.match('return'):
      return ASTReturn(self.parseExpr())
    elif tok.value == 'def':
      ret = self.parseDefInnerFunc()

      #if len(ret.name) != 1:
      #  print "don't use namespace!"
      #  sys.exit(-1)

      #realname = ret.name[0]
      #if realname == '_':
      #  realname = self.genTemporaryName()  
      #if self.findAt(tbl = self.local_symtbl, target = ret.name):
      #  print "already defined!"
      #  sys.exit(-1)

      #typename = convertType(ret.ret)
      #if not self.validateType(typename):
      #  print "not declare type"
      #  sys.exit(-1)
      
      #self.local_symtbl[realname] = {
      #  "attribute": ["lambda"], 
      #  "args": ret.args, 
      #  "type": typename, 
      #  "body": ret.body}

      return ret
    elif tok.type == 'id':
      self.token.nextToken()
      if self.token.tok.value == '[':
        history = []
        while self.token.match('['):
          history.append(self.parseSimpleExpr())
          self.token.match(']')
        return ASTIndexing(ASTWord(tok.type, tok.value), history)
      elif self.token.match('('):
        args = self.parseArgumentList()
        self.token.match(')')
        return ASTFuncCall(ASTWord(tok.type, tok.value), args)
      else:
        return ASTWord(tok.type, tok.value)
    elif tok.value == '_':
      self.token.nextToken()
      return ASTWord('v', tok.value)
    elif tok.value == '[':
      self.token.match('[')
      history = []
      tree = self.parseSimpleExpr()
      if self.token.match('...'):
        right = self.parseSimpleExpr()
        self.token.match(']')
        return ASTListGenerateType1(tree, right)
      elif self.token.tok.value == ',':
        history.append(tree)
        while self.token.match(','):
          item = self.parseSimpleExpr()
          history.append(item)
        self.token.match(']')
        return ASTListValue(history)
       
      self.token.match(']')
      return ASTListValue([tree])
    elif tok.value == '(':
      self.token.match('(')
      tree = self.parseSimpleExpr1()
      self.token.match(')')
      return ASTWrap(tree)

    return None

  def parseArgumentList(self):
    # 인자로 if나 for문이 올 수 있다면 아래것 그대로 사용하면 ㅇㅋ,
    # 하지만 그렇지 않다면...
    tree = self.parseExpr()
    if tree == None: return None

    history = [tree]
    while self.token.match(','):
      history.append(self.parseExpr())

    return ASTArgList(history)

  def parseMatchingCases(self):
    history = []
    while True:
      left = self.parseSimpleExpr()
      self.token.match('=>')
      right = self.parseSimpleExpr()
      if self.token.match(';'): break
      history.append(ASTCase(left, right))
      self.token.match(',')

    return ASTCases(history)

class IntermediateRuntimeCode:
  def __init__(self, symtbl):
    self.symtbl = symtbl
    self.stack_of_var = {}
    self.stack_of_fun = {}

    self.ir = IR()

  def convert(self):
    for key in self.symtbl:
      cursor = self.symtbl[key]
      type   = cursor["type"]
      if type == "variable":
        self.reserve_space(key, cursor["body"])
      elif type == "value":
        self.reserve_constant_space(key, cursor["body"])
      elif type == "function":
        self.process_function(key, cursor["body"])

  def reserve_space(self, name, body):
    type = body.type
    tname = ".".join(type.name.array)
    if tname == "int" \
      or tname == "uint":
      self.ir.define_var(name, "dd")

  def reserve_constant_space(self, name, body):
    type  = body.type
    tname = ".".join(type.name.array)

  def process_function(self, name, body):
    real_body = body.body
    if isinstance(real_body, ASTExprs):
      for item in real_body.exprs:
        self.process_expr(item)
    elif isinstance(real_body, ASTExpr):
      self.process_expr(real_body.expr)

  def process_expr(self, body):
    if isinstance(body, ASTIfStmt):
      return None
    elif isinstance(body, ASTForStmt):
      return None
    elif isinstance(body, ASTDefVar):
      return None
    elif isinstance(body, ASTDefVal):
      return None
    elif isinstance(body, ASTBlock):
      exprs = body.exprs
      for item in exprs.exprs:
        self.process_expr(item)
    else:
      return None

def convertIntToHex(value):
  string = str(value)
  if string[:2] == '0x':
    return hex(int(string[2:], 16))
  elif string[0] == '0':
    try:
      return hex(int(string, 8))
    except:
      return hex(int(string))
  else:
    return hex(int(string))

  return None

def convertFloatToHex(value):
  string = str(value)
  return None

# 아래 코드는 수정할 예정임  
class Transformation:
  def __init__(self, symtbl):
    self.symtbl = symtbl
    self.arg_symtbl   = {}
    self.local_symtbl = {}
    self.local_constant_symtbl = {}
    self.stringtbl    = []

  def convert(self):
    for key in self.symtbl:
      ast = self.symtbl[key]
      if isinstance(ast, ASTDeclFunc):
        # local 변수 Stack 필요.
        continue
      elif isinstance(ast, ASTDefVar):
        continue
      elif isinstance(ast, ASTDefVal):
        continue

  # search the symbol and return type of it.
  def searchSymbolTable(self, name):
    if self.arg_symtbl.has_key(name):
      return self.arg_symtbl[name]
    elif self.local_symtbl.has_key(name):
      return self.local_symtbl[name]
    elif self.local_constant_symtbl.has_key(name):
      return self.local_constant_symtbl[name]

    return None

  def processExpr(self):
    now = self.now
    if isinstance(now, ASTOperator):
      left  = self.transform(now.left)
      right = self.transform(now.right)
      # to construct
    if isinstance(now, ASTWord):
      if now.type == 'integerLiteral':
        convstr = convertIntToHex(now.value)
        typestr = ""
        if len(convstr) <= 2:
          typestr = "integer2"
        elif len(convstr) <= 4:
          typestr = "integer4"
        elif len(convstr) <= 8:
          typestr = "integer8"
        elif len(convstr) <= 16:
          typestr = "integer16"
        else:
          typestr = "number"

        return {"type": typestr, "value": convstr}
      elif now.type == 'floatLiteral':
        convstr = convertFloatToHex(now.value)
        return {"type": "float8", "value": convstr}
      elif now.type == 'stringLiteral':
        index = len(self.stringtbl)
        self.stringtbl.append(now.value)
        return {"type": "string", "index": index}
      elif now.type == 'id':
        regnum = len(self.symboltbl)
        # 단일이면 register, 크기가 있다면 start address를 register
        type   = self.searchSymbol(now.value)
        if self.isBasicType(type):
          return {"type": type, "register-num": regnum}
        else:
          return {"type": type, "register-num": regnum, "extendtype": "indrect"}
      else:
        print "I don't know how the ASTWord(%s) convert" % (now.name)
      return None
    elif isinstance(now, ASTVar):
      if self.searchSymbol(now.name) == None:
        print "duplicate symbol"
      self.local_symtbl[now.name] = convertType(now.type)
      ret = self.parseExpr(now.init)
    elif isinstance(now, ASTVal):
      if self.searchSymbol(now.name) == None:
        print "duplicate symbol"
      self.local_constant_symtbl[now.name] = now.type
      ret = self.parseExpr(now.init)

parser = Parser("sample.prg")
parser.parse()
#print parser.symbol_dict.hierarchy
#for key in parser.symbol_dict.hierarchy:
#  print key

def getName(target):
  if isinstance(target, ASTWord):
    return target.value
  
  return target
  
def evalTree(trees, symbol, tbl, opCodeList = []):
  def __check_symbol(tree):
    if not symbol.has_key(getName(tree)):
      print "undefined symbol : %s" % (getName(tree))
      sys.exit(-1)

  if trees == None:
    return opCodeList
  elif isinstance(trees, ASTExprs):
    for tree in trees.history:
      evalTree(tree, symbol, tbl, opCodeList)
  elif isinstance(trees, ASTSimpleExprs):
    for tree in trees.exprs:
      evalTree(tree, symbol, tbl, opCodeList)
  elif isinstance(trees, ASTExpr):
    expr = trees.expr
    evalTree(expr, symbol, tbl, opCodeList)
  elif isinstance(trees, ASTOperator):
    op, left, right = trees.name, trees.left, trees.right
    
    __check_symbol(left)
    __check_symbol(right)
    
    lt, rt = symbol[getName(left)], symbol[getName(right)]

    print tbl[getName(left)], tbl[getName(right)]
    
    name, info = symbol_dict.search(lt['@stype'])
    if not info.has_key('@type'):
      print "Not class or function"
      sys.exit(-1)
		
    members = info['@children']
    if not members.has_key(op):
      print "not found %s in %s" % (op, ".".join(name))
      sys.exit(-1)
		
  return opCodeList

def make_fname(array):
  if len(array) == 1:
    name, info = symbol_dict.search(array[0])
    return name
    
hier = symbol_dict.hierarchy
for key in hier:
	print key
	
sys.exit(-1)

def translate_to_reg(ind):
  table = ["rdi", "rsi", "rdx", "rcx", "r8", "r9",
           "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6", "xmm7"]
  
  if ind >= len(table):
    print "Be over maximum of available register"
    pass

  return table[ind]
  
for key in hier:
  core = hier['add'].info

  symbol_type = core['@type']  
  if symbol_type == 'function':
    symbol   = {}
    transtbl = {}
    args     = core['@arguments']
    for i, item in enumerate(args):
      temp = {'@scope': 'argument'}
      temp['@rtype'] = convertType(args[item])
      temp['@stype'] = make_fname(args[item].name.array)
      temp['@register'] = translate_to_reg(i)
      symbol[item] = temp

      # 변수에 할당된 register를 추적하기위한 table
      transtbl[item] = temp['@register']
      
    core['@assembly'] = evalTree(trees = core['@body'], symbol = symbol, tbl = transtbl)

  break
    
